/// Represents a reference to an object in a P4 program.
///
/// This is a thin wrapper around a 'const Member*' to (1) enforce invariants on which forms of
/// Members can represent state variables and (2) enable the use of StateVariables as map keys.
class StateVariable : Expression {
    #noconstructor

    /// The wrapped reference.
    const Expression *ref;

    /// The expression type is derived from the member.
    /// Implicit conversions to allow implementations to be treated like a Member*.
#emit
    operator const Expression *() const { return ref; }
#end
    Expression const &operator*() const { return *ref; }
    Expression operator->() const { return ref; }

    /// StateVariables can be Members, PathExpressions, or ArrayIndices.
    StateVariable(Member member) : Expression(member->getSourceInfo(), member->type), ref(member) {}
    /// The expression type is derived from the path.
    StateVariable(PathExpression path) : Expression(path->getSourceInfo(), path->type), ref(path) {}
    StateVariable(ArrayIndex arr) : Expression(arr->getSourceInfo(), arr->type), ref(arr) {}

    /// Implements comparisons so that StateVariables can be used as map keys.
    bool operator==(const StateVariable &other) const override {
        // Delegate to IR's notion of equality.
        return *ref == *other.ref;
    }

    /// Implements comparisons so that StateVariables can be used as map keys.
    /// Note that we ignore the type here.
    equiv {
        // We use a custom compare function.
        // TODO: Is there a faster way to implement this comparison?
        return compare(ref, a.ref) == 0;
    }

    isSemanticallyLess {
        if (static_cast<const Node *>(this) == &a_) return false;
        if (typeId() != a_.typeId()) return typeId() < a_.typeId();
        auto &a = static_cast<const StateVariable &>(a_);
        return compare(ref, a.ref) < 0;
    }

    int compare(const Expression *e1, const Expression *e2) const {
        // e1 is a Member.
        if (const auto *m1 = e1->to<Member>()) {
            if (const auto *m2 = e2->to<Member>()) {
                return compare(m1, m2);
            }
            if (e2->is<PathExpression>()) {
                return 1;
            }
            if (e2->is<ArrayIndex>()) {
                return 1;
            }
        }
        // e1 is a PathExpression.
        if (const auto *p1 = e1->to<PathExpression>()) {
            if (const auto *p2 = e2->to<PathExpression>()) {
                return compare(p1, p2);
            }
            if (e2->is<Member>()) {
                return -1;
            }
            if (e2->is<ArrayIndex>()) {
                return 1;
            }
        }
        // e1 is a ArrayIndex.
        if (const auto *a1 = e1->to<ArrayIndex>()) {
            if (const auto *a2 = e2->to<ArrayIndex>()) {
                return compare(a1, a2);
            }
            if (e2->is<Member>()) {
                return -1;
            }
            if (e2->is<PathExpression>()) {
                return -1;
            }
        }
        BUG("Either %1% of type %2% or %3% of type %4% is not a valid StateVariable", e1, e1->node_type_name(), e2, e2->node_type_name());
    }

    int compare(const Member *m1, const Member *m2) const {
        auto result = compare(m1->expr, m2->expr);
        if (result != 0) {
            return result;
        }
        if (m1->member.name < m2->member.name) {
            return -1;
        }
        if (m1->member.name > m2->member.name) {
            return 1;
        }
        return 0;
    }

    int compare(const PathExpression *p1, const PathExpression *p2) const {
        if (p1->path->name.name < p2->path->name.name) {
            return -1;
        }
        if (p1->path->name.name > p2->path->name.name) {
            return 1;
        }
        return 0;
    }

    int compare(const ArrayIndex *a1, const ArrayIndex *a2) const {
        auto result = compare(a1->left, a2->left);
        if (result != 0) {
            return result;
        }
        auto a1Val = a1->right->to<Constant>();
        BUG_CHECK(a1Val != nullptr, "Value %1% is not a constant. Only constants are supported as part of a state variable.", a1->right);
        auto a2Val = a2->right->to<Constant>();
        BUG_CHECK(a2Val != nullptr, "Value %1% is not a constant. Only constants are supported as part of a state variable.", a2->right);
        if (a1Val->value < a2Val->value) {
            return -1;
        }
        if (a1Val->value > a2Val->value) {
            return 1;
        }
        return 0;
    }

    uint64_t hash() const {
        return hash(0, ref);
    }

    uint64_t hash(uint64_t seed, const IR::Expression *expression) const {
        // expression is a Member.
        if (const auto *member = expression->to<IR::Member>()) {
            return hash(seed, member);
        }
        // expression is a PathExpression.
        if (const auto *pathExpression = expression->to<IR::PathExpression>()) {
            return hash(seed, pathExpression);
        }
        // expression is a ArrayIndex.
        if (const auto *arrayIndex = expression->to<IR::ArrayIndex>()) {
            return hash(seed, arrayIndex);
        }
        BUG("Either %1% of type %2% is not a valid StateVariable", expression,
            expression->node_type_name());
    }

    uint64_t hash(uint64_t seed, const IR::Member *member) const {
        return hash(Util::hash_combine(seed, std::hash<cstring>()(member->member)), member->expr);
    }

    uint64_t hash(uint64_t seed, const IR::PathExpression *pathExpression) const {
        return Util::hash_combine(seed, std::hash<cstring>()(pathExpression->path->name));
    }

    uint64_t hash(uint64_t seed, const IR::ArrayIndex *arrayIndex) const {
        const auto *arrayIndexVal = arrayIndex->right->to<IR::Constant>();
        BUG_CHECK(
            arrayIndexVal != nullptr,
            "Value %1% is not a constant. Only constants are supported as part of a state variable.",
            arrayIndex->right);
        return hash(Util::hash_combine(seed, std::hash<big_int>()(arrayIndexVal->value)),
                                 arrayIndex->left);
    }

    toString { return ref->toString(); }

    dbprint { ref->dbprint(out); }
}
#emit
namespace IR {
/// Equals for StateVariable pointers. We only compare the label.
struct StateVariableEqual {
    bool operator()(const IR::StateVariable *s1, const IR::StateVariable *s2) const {
        return s1->equiv(*s2);
    }
    bool operator()(const IR::StateVariable &s1, const IR::StateVariable &s2) const {
        return s1.equiv(s2);
    }
};

/// Less for StateVariable pointers. We only compare the label.
struct StateVariableLess {
    bool operator()(const IR::StateVariable *s1, const IR::StateVariable *s2) const {
        return s1->isSemanticallyLess(*s2);
    }
    bool operator()(const IR::StateVariable &s1, const IR::StateVariable &s2) const {
        return s1.isSemanticallyLess(s2);
    }
};

/// Hash for StateVariable pointers. We only hash the label.
struct StateVariableHash {
    size_t operator()(const IR::StateVariable *s1) const {
        return Util::Hasher<uint64_t>()(s1->hash());
    }

    size_t operator()(const IR::StateVariable &s1) const {
        return Util::Hasher<uint64_t>()(s1.hash());
    }
};
}  // namespace IR
#end

/// Signifies that a particular expression is tainted.
/// This tainted expression must be resolved explicitly.
class TaintExpression : Expression {
    toString { return "TaintedExpression(" + type->toString() + ")"; }

    dbprint { out << "TaintedExpression(" << type << ")"; }
}

/// Signifies that a particular expression is a symbolic variable with a label.
/// These variables are intended to be consumed by SMT/SAT solvers.
class SymbolicVariable : Expression {
#noconstructor

    isSemanticallyLess {
        if (static_cast<const Node *>(this) == &a_) return false;
        if (typeId() !=  a_.typeId()) return typeId() <  a_.typeId();
        auto &a = static_cast<const SymbolicVariable &>(a_);
        return label < a.label; /* ignore type */
    }


    /// The label of the symbolic variable.
    cstring label;

    /// A symbolic variable always has a type and no source info.
    SymbolicVariable(Type type, cstring label) : Expression(type), label(label) {}

    toString { return "|" + label +"(" + type->toString() + ")|"; }

    dbprint { out << "|" + label +"(" << type << ")|"; }
}
#emit
namespace IR {
/// Equals for SymbolicVariable pointers. We only compare the label.
struct SymbolicVariableEqual {
    bool operator()(const IR::SymbolicVariable *s1, const IR::SymbolicVariable *s2) const {
        return s1->label == s2->label;
    }
    bool operator()(const IR::SymbolicVariable &s1, const IR::SymbolicVariable &s2) const {
        return s1.label == s2.label;
    }
};

/// Less for SymbolicVariable pointers. We only compare the label.
struct SymbolicVariableLess {
    bool operator()(const IR::SymbolicVariable *s1, const IR::SymbolicVariable *s2) const {
        return s1->isSemanticallyLess(*s2);
    }
    bool operator()(const IR::SymbolicVariable &s1, const IR::SymbolicVariable &s2) const {
        return s1.isSemanticallyLess(s2);
    }
};

/// Hash for SymbolicVariable pointers. We only hash the label.
struct SymbolicVariableHash {
    size_t operator()(const IR::SymbolicVariable *s1) const {
        return std::hash<cstring>()(s1->label);
    }

    size_t operator()(const IR::SymbolicVariable &s1) const {
        return std::hash<cstring>()(s1.label);
    }
};
}  // namespace IR
#end

/// This type replaces Type_Varbits and can store information about the current size
class Extracted_Varbits : Type_Bits {
 public:
#emit
    void *operator new(size_t size) { return ::operator new(size); }
#end
    /// The assigned size of this varbit (assigned by extract calls).
    int assignedSize;

    /// Returns the current width this variable bit type has.
    int width_bits() const override { return assignedSize; }

    equiv {
        // Ignore the current size and only check for equivalence of the assigned size.
        return size == a.size;
    }

    operator== {
        // Ignore the current size and only check for equivalence of the assigned size.
        return size == a.size;
    }

    cstring baseName() const { return "SizedVarbit"_cs; }

    toString {
        return baseName() + "<"_cs + Util::toString(size) + ">"_cs + "<"_cs + Util::toString(assignedSize) +
               ">"_cs;
    }

    dbprint { out << toString(); }
}

/// Defines a concolic variable that may be part of expressions.
/// This variable must later be resolved and is converted into a symbolic expression.
class ConcolicVariable : SymbolicVariable {
    #noconstructor

private:
    static cstring produceLabel(cstring methodName, int srcIdentifier, int concolicId ) {
        std::stringstream sstr;
        sstr << methodName << "_" << srcIdentifier << "_" << concolicId;
        return sstr.str();
    }

public:
    /// Arguments to the concolic method.
    Vector<Argument> arguments;

    /// The unique identifier of the source the produces this concolic variable.
    int srcIdentifier;

    /// Some identifiers produce multiple concolic variables. This ID keeps track of the offsets.
    int concolicId;

    /// Nodes that are associated with this concolic variable. This may be declarations.
    optional inline IndexedVector<Node> associatedNodes;

    /// The name of the concolic method that this variable targets.
    inline cstring concolicMethodName = cstring::empty;

    toString {
        std::string argumentStr = "";
        std::string sep = "";
        for (const auto *arg : *arguments) {
            argumentStr += sep + arg->toString();
            sep = ", ";
        }
        return "Concolic_" + label + "(" + argumentStr + ")";
    }

    dbprint {
        out << "Concolic_" << label << "(" << arguments << ")";
    }

    isSemanticallyLess {
        if (static_cast<const Node *>(this) == &a_) return false;
        if (typeId() !=  a_.typeId()) return typeId() <  a_.typeId();
        auto &a = static_cast<const ConcolicVariable &>(a_);
        return label < a.label; /* ignore type */
    }

    visit_children { v.visit(type, "type"); }

    ConcolicVariable(const Type *type, cstring methodName,
                     const Vector<Argument> *arguments, int srcIdentifier, int concolicId,
                     const IndexedVector<Node> &associatedNodes)
        : SymbolicVariable(type, produceLabel(methodName, srcIdentifier, concolicId)),
          arguments(arguments),
          srcIdentifier(srcIdentifier),
          concolicId(concolicId),
          associatedNodes(associatedNodes),
          concolicMethodName(methodName) {}

    ConcolicVariable(const Type *type, cstring methodName,
                     const Vector<Argument> *arguments, int srcIdentifier, int concolicId)
        : SymbolicVariable(type, produceLabel(methodName, srcIdentifier, concolicId)),
          arguments(arguments),
          srcIdentifier(srcIdentifier),
          concolicId(concolicId),
          concolicMethodName(methodName) {}
}

/// An extension of a struct expression. Also tracks validity as an expression.
class HeaderExpression : StructExpression {
    /// Whether this struct expression is valid. Mostly relevant to header expressions.
    Expression validity;

    dbprint {
        out <<"{" << Log::endl << IndentCtl::indent;
        out << "$headerValid:" << validity <<";" << Log::endl;
        for (auto &field : components) {
            out << Log::endl << field << ';';
        }
        out << Log::endl << IndentCtl::unindent << "}";
    }

    validate {
        components.check_null(); components.validate();
        BUG_CHECK(structType == nullptr || structType->is<IR::Type_Header>(), "%1%: unexpected header type", structType->node_type_name());
    }
}

/// An wrapper which models an InOut argument.
/// Contains both a copy of the original reference as well as the resolved value of that reference.
class InOutReference : Expression {
/// Because we do not use a reference for "ref" and also inline the member the irgenerator produces
/// a constructor that does not compile. We need to write the constructor manually instead.
#noconstructor
#nomethod_constructor
    /// The original reference.
    inline StateVariable ref;
    /// The value of the reference after it was resolved.
    Expression resolvedRef;

    InOutReference(JSONLoader & json) : Expression(json), ref(json) {
        json.load("resolvedRef", resolvedRef);
    }

    InOutReference(Util::SourceInfo srcInfo, IR::StateVariable &ref, const Expression* resolvedRef) :
        Expression(srcInfo, ref.type), ref(ref), resolvedRef(resolvedRef)
        { validate(); }

    InOutReference(IR::StateVariable &ref, const Expression* resolvedRef) :
        Expression(ref.type), ref(ref), resolvedRef(resolvedRef)
        { validate(); }

    toString { return ref->toString() + "("_cs + resolvedRef->toString() + ")"_cs; }

    dbprint { out << ref << "(" << resolvedRef << ")"; }
}
